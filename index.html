<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
<title></title>
<link rel="icon" type="image/svg" href="icon.svg" />
<link rel="apple-touch-icon" href="icon.png" sizes="192x192" />
<link rel="manifest" href="app.json" />
<link rel="stylesheet" href="pico.css" />
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="menu">
			<div id="logo">
				<a id="title" href="javascript:pico.app.onReset();">
					<span id="titleText"></span>
					<img id="titleIcon" src="" />
				</a>
				<a id="subtitle" href="javascript:top.location.reload();">
					<span id="subtitleText"></span>
					<img id="subtitleIcon" src="" />
				</a>
			</div>
		</div>
		<div class="menu center">
			<a class="item light secret" id="action" href="javascript:pico.app.onAction();">
				<span id="actionText"></span>
				<img class="icon" id="actionIcon" src="" />
			</a>
		</div>
		<div class="menu">
			<a class="item clear secret" id="minus" href="javascript:pico.app.onSelect(-1);">
				<span id="minusText">-</span>
				<img class="icon" id="minusIcon" src="" />
			</a>
			<a class="item light secret" id="select" href="javascript:pico.app.onSelect(0);">
				<span id="selectText"></span>
				<img class="icon" id="selectIcon" src="" />
			</a>
			<a class="item clear secret" id="plus" href="javascript:pico.app.onSelect(+1);">
				<span id="plusText">+</span>
				<img class="icon" id="plusIcon" src="" />
			</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>#
	<div id="version"></div>
</h6>
<!--script>console.log = () => {};</script!-->
<script src="pico.js"></script>
<script src="index.js"></script>
<!--Event--><script>

// Change label.
async function picoLabel(id, text=null, icon=null) {
	await pico.app.setLabel(id, text, icon);
}

// Change title.
async function picoTitle(text=null, nolabel=false, noheader=false) {
	await pico.app.setTitle(text, nolabel, noheader);
}

// Switch app script.
async function picoSwitchApp(target=null, refer=null, title=null) {
	return await pico.app.switchApp(target, refer, title);
}

// Return app script.
async function picoReturnApp() {
	return await pico.app.returnApp();
}

// Share app url.
async function picoShareApp() {
	await pico.app.shareApp();
}

// Share screen image.
async function picoShareScreen(c=0, bg=1) {
	await pico.app.shareScreen(c, bg);
}

// Lock screen with wakelock.
function picoLockScreen(enable=true) {
	pico.app.lockScreen(enable);
}

// Check wide screen and return true if landscape mode.
function picoWideScreen() {
	return pico.app.wideScreen();
}

// Read from clipboard.
async function picoReadClipboard() {
	return await pico.app.readClipboard();
}

// Write to clipboard.
async function picoWriteClipboard(text) {
	await pico.app.writeClipboard(text);
}

// App mode.
function picoAppMode() {
	return pico.app.version > 0;
}

//************************************************************/

// Namespace.
var pico = pico || {};

// App class.
pico.App = class {
	static count = 0; // Object count.
	static script = "app.js"; // Default script.
	static pixels = [ // App loading pixels.
		[0,7,7, 9,1,1, 9,5,1, 9,2,2, 9,4,2, 9,3,3, 9,2,4, 9,4,4, 9,1,5, 9,5,5],
		[0,7,7, 9,3,3],
		[0,7,7, 9,5,1, 9,1,5],
		[0,7,7, 9,5,1, 9,3,3, 9,1,5],
		[0,7,7, 9,1,1, 9,5,1, 9,1,5, 9,5,5],
		[0,7,7, 9,1,1, 9,5,1, 9,3,3, 9,1,5, 9,5,5],
		[0,7,7, 9,1,1, 9,5,1, 9,1,3, 9,5,3, 9,1,5, 9,5,5],
	];
	static timeout = 1200; // Loading maximum time.

	// constructor.
	constructor() {
		pico.App.count++;
		this.lock = "picoAppLock" + pico.App.count + Date.now(); // Lock object identifier.
		this.wakeLock = null; // Wake lock object.
		this.image = new pico.Image(""); // App offscreen image.
		this.loading = 1; // App loading count.
		this.state = null; // App state.
		this.angle = 0; // App loading icon angle.
		this.frame = 0; // App loading icon frame.

		this.refer = picoString("r"); // Refer script/url.
		this.script = picoString("s") ? picoString("s") : pico.App.script; // App script.
		this.title = picoString("t"); // App title.
		this.version = picoNumber("v"); // App version.

		this.author = "*"; // App author.
		this.timestamp = ""; // Timestamp.

		// Load app information.
		let e = document.getElementById("author");
		if (e && e.innerText) {
			this.author = e.innerText;
		} else {
			let path = window.location.pathname.replace(/(^\/|[\?\#].*$|\.\w+$|\/$)/g, "");
			if (path.length > 32) {
				path = ".." + path.slice(-30);
			}
			this.author = window.location.hostname + "/" + path;
			if (e) {
				e.innerText = this.author;
			}
		}
		e = document.getElementById("version");
		if (e && e.innerText) {
			this.timestamp = e.innerText;
		} else {
			let date = new Date(document.lastModified);
			let mon = ("0" + (date.getMonth() + 1)).slice(-2);
			let day = ("0" + date.getDate()).slice(-2);
			this.timestamp = mon + day;
			if (e) {
				e.innerText = this.timestamp;
			}
		}

		// Load app script.
		this.state = "LOADING";
		this.loadScripts(this.script.split(/,/)).then(async () => {
			window.addEventListener("resize", async () => {
				console.log("Window resized.");
				await this.onResize()
			}); // Resize.
			this.state = "LOADED"; // End loading.
			this.onLoaded(); // Loaded.
		}).catch(() => {
			console.log("Load failed.");
			this.state = "ERROR"; // App not found.
		});

		// On loading.
		this.onLoading();
	}

	// Load scripts.
	async loadScripts(scripts, index=0) {
		return new Promise(async (resolve, reject) => {
			console.log("Load scripts: " + (index+1) + "/" + scripts.length);
			this.loadScript(scripts[index]).then(async () => {
				if (index + 1 < scripts.length) {
					await this.loadScripts(scripts, index + 1);
				}
				console.log("Loaded all scripts.");
				resolve();
			}).catch(() => {
				reject();
			});
		}); // end of new Promise.
	}

	// Load script.
	async loadScript(script, timeout=10000) {
		return new Promise(async (resolve, reject) => {
			console.log("Load script: " + script);
			let loader = document.createElement('script');
			loader.addEventListener("load", async () => {
				navigator.locks.request(this.lock, async (lock) => {
					if (timeout > 0) {
						console.log("Loaded: " + script);
						timeout = 0;
						resolve();
					}
				}); // end of lock.
			}); // Loaded.
			setTimeout(() => {
				navigator.locks.request(this.lock, async (lock) => {
					if (timeout > 0) {
						console.log("Load timed out: " + script);
						loader.src = null; // Load cancel.
						timeout = 0;
						reject();
					}
				}); // end of lock.
			}, timeout);
			loader.src = script; // Set url after onload event handler to avoid onload hook timing bug.
			document.body.appendChild(loader);
		}); // end of new Promise.
	}

	// On reset button.
	async onReset() {
		await navigator.locks.request(this.lock, async (lock) => {

			// Back to refer script/page or reload top page.
			if (!await this.returnApp()) {
				await this.resetApp();
			}
		}); // end of lock.
	}

	// On acction button.
	async onAction() {
		if (typeof appAction === "function") {
			await navigator.locks.request(this.lock, async (lock) => {
				await appAction();
			}); // end of lock.
		}
	}

	// On select button.
	async onSelect(x) {
		if (typeof appSelect === "function") {
			await navigator.locks.request(this.lock, async (lock) => {
				await appSelect(x);
			}); // end of lock.
		}
	}

	// On resize event.
	async onResize() {
		if (typeof appResize === "function") {
			await navigator.locks.request(this.lock, async (lock) => {
				await appResize();
			}); // end of lock.
		}
	}

	// On loading event.
	async onLoading() {
		try {
			// Load loop.
			for (this.loading = 1; this.loading < pico.App.timeout; this.loading++) {
				await navigator.locks.request(this.lock, async (lock) => {
					const speed = 20, oneroll = 360/speed * 3, oneloop = 360/speed * 6;
					let waiting = this.loading < oneloop-oneroll || picoMod(this.loading-1, oneloop) == 0;
					console.log("load " + this.loading + " " + oneroll + "/" + oneloop + " -> " + waiting);
					if (this.state != "LOADING" && this.state != "LOADED" && waiting) {
						this.loading = pico.App.timeout;
						return;
					}
					picoClear();
					let rolling = picoMod(this.loading-1, oneloop) >= oneloop-oneroll;
					if (rolling) {
						this.angle = picoMod(this.angle + speed, 360);
						this.frame = picoRandom(pico.App.pixels.length - 1) + 1;
					}
					if (this.loading >= oneloop-oneroll) {
						picoSprite(pico.App.pixels[this.frame], 3, 0,0, this.angle,picoMotion()?1.6:2);
						if (!rolling && this.loading >= oneloop) {
							picoChar(this.state, -1, 0,16, 0,1);
						}
					}
					await picoFlip(10);
				}); // end of lock.
			}
			// Error loop.
			if (this.state != "START") {
				picoFlush(); // Flush to skip first read.
				for (;;) {
					await picoRead();
					await navigator.locks.request(this.lock, async (lock) => {
						picoClear();
						if (picoAction()) {
							await this.resetApp();
							return;
						} else {
							picoSprite(pico.App.pixels[0], -1, 0,0, 0,picoMotion()?1.6:2);
							picoChar(this.state, -1, 0,16, 0,1);
						}
						await picoFlip(10);
					}); // end of lock.
				}
			}
			picoFlush(); // Flush to skip first read.
			console.log("Start app.");
		} catch (error) {
			console.error(error.name, error.message);
		}
	}
	
	// On loaded event.
	async onLoaded() {
		try {
			// Load app.
			if (typeof appLoad === "function") {
				console.log("Loaded app.");
				await appLoad();
			}
			// Start app.
			await navigator.locks.request(this.lock, async (lock) => {
				if (typeof appMain === "function") {
					console.log("Starting app.");
					this.state = "START"; // End loading.
				} else {
					console.log("App not found.");
					this.state = "ERROR"; // App not found.
					return;
				}
			}); // end of lock.
			// Main loop.
			for (;;) {
				await picoRead();
				await navigator.locks.request(this.lock, async (lock) => {
					picoClear();
					await appMain();
					await picoFlip(0);
				}); // end of lock.
			}
		} catch (error) {
			console.error(error.name, error.message);
		}
	}

	// Change label.
	async setLabel(id, text=null, icon=null) {
		let e = document.getElementById(id);
		if (e) {
			e.style.display = (text || icon) ? "flex" : "none";
			let e1 = document.getElementById(id + "Text");
			let e2 = document.getElementById(id + "Icon");
			if (e2 && (text || icon)) {
				e2.style.display = "flex";
				e2.src = icon ? icon : await this.image.textData(text);
				if (e1) {
					e1.style.display = "none";
				}
			} else if (e1 && text) {
				e1.style.display = "flex";
				e1.innerText = text;
				if (e2) {
					e2.style.display = "none";
				}
			} else if (text) {
				e.innerText = text;
			}
		}
		picoFlush();
	}

	// Change title.
	async setTitle(title=null, nolabel=false, noheader=false) {
		for (let e of document.getElementsByTagName("title")) {
			if (title) {
				e.style.display = "flex";
				e.innerText = title;
			} else {
				e.style.display = "none";
				e.innerText = "";
			}
		}
		let e = document.getElementById("header")
		if (e) {
			e.style.display = (title && !noheader) ? "flex" : "none";
		}
		if (!nolabel) {
			if (this.title) {
				await picoLabel("title", this.title);
				await picoLabel("subtitle", title);
			} else {
				await picoLabel("title", title);
				await picoLabel("subtitle");
			}
		} else {
			await picoLabel("title");
			await picoLabel("subtitle");
		}
	}

	// Switch app script.
	async switchApp(target=null, refer=null, title=null) {
		if (this.version > 0) {
			picoSetString(this.version, "v");
		}

		// Change and reload script.
		if (target && target.match(/[^=]*js$/)) {
			if (refer && !picoString("r")) {
				picoSetString(refer, "r");
			}
			if (title && !picoString("t")) {
				picoSetString(title, "t");
			}
			picoSetString(target, "s");
			await picoReload();
			return true;

		// Jump to target page.
		} else if (target) {
			if (refer && !picoString("r")) {
				picoSetString(refer, "r");
			}
			if (title && !picoString("t")) {
				picoSetString(title, "t");
			}
			await picoReload(target);
			return true;
		}
		return false;
	}

	// Return app script.
	async returnApp() {
		if (this.refer) {
			if (this.version > 0) {
				picoSetString(this.version, "v");
			}
			picoSetString("", "r");
			picoSetString("", "t");

			// Back to refer script.
			if (this.refer.match(/[^=]*js$/)) {
				picoSetString(this.refer, "s");
				await picoReload();
				return true;

			// Back to refer page.
			} else {
				picoSetString("", "s");
				await picoReload(this.refer);
				return true;
			}

		}
		return false;
	}

	// Reload top page.
	async resetApp() {
		picoResetParams();
		if (this.version > 0) {
			picoSetString(this.version, "v");
		}
		await picoReload();
		return true;
	}

	// Share app url.
	async shareApp() {
		if (this.script && this.script != pico.App.script) {
			picoSetString(this.script, "s");
		}
		await picoShare();
	}

	// Share screen image.
	async shareScreen(c=0, bg=1) {
		let watermark = this.author + "#" + this.timestamp;
		let file = await picoScreenFile(watermark, c, bg);
		let files = [file];
		await picoShare(null, files);
	}

	// Lock screen with wakelock.
	lockScreen(enable=true) {
		try {

			// Wake lock.
			// Not work on iOS 16 PWA.
			// https://bugs.webkit.org/show_bug.cgi?id=254545
			if (navigator.wakeLock) {
				if (enable) {
					console.log("Request wake lock.");
					this.wakeLock = navigator.wakeLock.request("screen");
				} else if (this.wakeLock) {
					console.log("Release wake lock.");
					this.wakeLock.release();
					this.wakeLock = null;
				}
			} else {
				console.log("No wake lock.");
			}
		} catch (error) {
			console.error(error.name, error.message);
		}
	}

	// Check wide screen and return true if landscape mode.
	wideScreen() {
		return window.matchMedia("(min-aspect-ratio: 1.0)").matches;
	}

	// Read clipboard.
	async readClipboard() {
		try {
			return await navigator.clipboard.readText();
		} catch (error) {
			console.error(error.name, error.message);
		}
	}

	// Write clipboard.
	async writeClipboard(text) {
		try {
			await navigator.clipboard.writeText(text);
		} catch (error) {
			console.error(error.name, error.message);
		}
	}
}

// Master app.
pico.app = new pico.App();
</script><!--/Event-->
</body>
</html>
