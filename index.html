<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
<title>Pico</title>
<link rel="icon" type="image/svg" href="icon.svg" />
<link rel="apple-touch-icon" href="icon.png" sizes="192x192" />
<link rel="manifest" href="manifest.json" />
<link rel="stylesheet" href="stylesheet.css" />
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<a id="title" href="./index.html">Pico</a>
			<div id="subtitle">
				<a href="bros.html">.</a><a href="dice.html">.</a>
			</div>
		</div>
		<div class="menu center">
			<a class="item light secret" id="action" href="javascript:menuAction();">
				<span id="actionText"></span>
				<img class="icon" id="actionIcon" src="" />
			</a>
		</div>
		<div class="menu">
			<a class="item clear" id="minus" href="javascript:menuSelect(-1);">-</a>
			<a class="item light" id="select" href="javascript:menuSelect(0);">
				<span id="selectText"></span>
				<img class="icon" id="selectIcon" src="" />
			</a>
			<a class="item clear" id="plus" href="javascript:menuSelect(+1);">+</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>/
	<div id="version"></div>
</h6>
<!--script>console.log = () => {};</script!-->
<script src="daemon.js"></script>
<script src="image.js"></script>
<script src="param.js"></script>
<script src="sound.js"></script>
<script src="touch.js"></script>
<!--Data--><script>
var maxwidth = 20, maxheight = 20; // Canvas max size.
var width = 7, height = 7; // Canvas size.
var xoffset = picoDiv(maxwidth - width, 2); // Canvas offset.
var yoffset = picoDiv(maxheight - height, 2); // Canvas offset.
const maxanime = 20; // Buffer max size.
var anime = 1; // Buffer count.
var minanime = 1; // Buffer min index.
var frame = 0; // Anime frame count.
var buffers = []; // Pixels buffers.
var animeflag = 0; // Anime editing flag.
var playing = 1; // Playing count.
var pixels = []; // Canvas pixels.
var colors = [255,255,255,255,223,175,159,255,247,191,191,191,231,0,95,0,119,239,0,151,63,167,0,0,143,0,119,0,63,23]; // Colors.
var depth = 10; // Color count.
const maxcolor = 10; // Color max size.
var colorflag = 0; // Color editing flag.
var appurl = null; // Referenced url.
</script><!--/Data-->
<!--Menu--><script>

// Enable or disable menu.
function updateMenu(id, enable, text=null, icon=null) {
	let e = document.getElementById(id);
	if (e) {
		e.style.display = enable ? "flex" : "none";
		let e1 = document.getElementById(id + "Text");
		if (e1) {
			e1.style.display = text ? "flex" : "none";
			e1.innerText = text ? text : "";
		} else {
			e.style.display = text ? "flex" : "none";
			e.innerText = text ? text : "";
		}
		let e2 = document.getElementById(id + "Icon");
		if (e2) {
			e2.style.display = icon ? "flex" : "none";
			e2.src = icon ? icon : "";
		}
	}
}

// Set darkmode.
async function darkmode(enable) {
	let e = document.body;
	if (e) {
		e.style.backgroundColor = enable ? "#888" : "#fff";
		e.style.color = enable ? "#fff" : "#888";
	}
	updateMenu("title", !enable);
	updateMenu("subtitle", !enable);
}

// Update buttons.
function updateButtons() {
	if (colorflag) {
		updateMenu("select", true, "" + depth);
	} else if (animeflag) {
		updateMenu("select", true, "" + anime);
	} else {
		updateMenu("select", true, "x" + width);
	}
}

// Update icon image.
async function updateIcons(force = true) {

	// Update buffer.
	if (force || buffers[frame]) {
		//console.log("Update" + frame + ": " + buffers[frame]);

		// Store canvas pixels to buffers.
		buffers[frame] = [0, width, height];
		for (let j = yoffset; j < yoffset + height; j++) {
			for (let i = xoffset; i < xoffset + width; i++) {
				if (pixels[j][i]) {
					let k = buffers[frame].length;
					buffers[frame][k] = pixels[j][i];
					buffers[frame][k+1] = i - xoffset;
					buffers[frame][k+2] = j - yoffset;
				}
			}
		}
		if (buffers[frame].length <= 3) {
			buffers[frame] = null;
		}
	}

	// Update icon image.
	if (buffers[frame]) {
		let data = await picoSpriteData(buffers[frame], colors);
		updateMenu("action", true, null, data);
	} else {
		updateMenu("action", true, "^");
	}
	updateButtons();
}

// Action button for back to app or start sharing.
async function menuAction() {

	// Back to app or start sharing.
	picoResetParams();

	// Create num code to share url.
	let k = 0;
	for (let p = 0; p < maxanime; p++) {
		if (buffers[p]) {
			picoSetNumcode(buffers[p], k);
			k++;
		}
	}
	if (k == 0) {
		picoSetNumcode([0,7,7], k);
		k++
	}
	if (
		((colors[0] == 255 && colors[1] == 255 && colors[2] == 255) ||
		(colors[0] == 0 && colors[1] == 0 && colors[2] == 0))) {
		picoSetColcode(colors, k);
	}

	// Back to app or start sharing.
	if (appurl) {
		await picoReload(appurl);
	} else {
		await picoShare();
	}
}

// Select button.
function menuSelect(x) {

	// Change menu mode.
	if (x == 0) {
		animeflag = animeflag ? 0 : 1;
		colorflag = 0;

	// Change color depth.
	} else if (colorflag) {
		depth = depth + x < 1 ? 1 : depth + x >= maxcolor ? maxcolor : depth + x;

	// Change canvas frame.
	} else if (animeflag) {
		anime = anime + x < 1 ? 1 : anime + x >= maxanime ? maxanime : anime + x;
		frame = frame < anime ? frame : anime - 1;
		//playing = -1; // Restart.

	// Change canvas size.
	} else {
		width = width + x < 3 ? 3 : width + x > maxwidth ? maxwidth : width + x;
		height = height + x < 3 ? 3 : height + x > maxheight ? maxheight : height + x;
		xoffset = picoDiv(maxwidth - width, 2);
		yoffset = picoDiv(maxheight - height, 2);
		//console.log("Size: " + width + "x" + height + " + " + xoffset + "," + yoffset);
		//playing = -1; // Restart.
	}

	picoBeep(1.2, 0.1);	
	updateIcons(false);
	picoFlush();
}
</script><!--/Menu-->
<!--Main--><script>
async function main() {

	// Initialize pixels on max size.
	for (let j = 0; j < maxheight; j++) {
		pixels[j] = [];
		for (let i = 0; i < maxwidth; i++) {
			pixels[j][i] = 0;
		}
	}

	// Load params.
	let keys = picoKeys();

	// Load data and frames.
	let frameselecting = 0, frameselected = -1;
	for (let k = 0; k < keys.length; k++) {
		console.log("Param" + k + ": " + keys[k] + " -> " + picoStrings(keys[k]));

		// Load referenced url.
		if (keys[k] == "u") {
			appurl = picoStrings(keys[k]);
			darkmode(true);

		// Load colors param.
		} else if (keys[k] == "z") {
			colors = picoNumbers(keys[k]);
			//colors = picoColcode(k);
			console.log("Color: " + colors);

		// Load pixels param.
		} else {
			let numcode = picoNumcode(k);

			// Load colors.
			if ((numcode[0] == 0 && numcode[1] == 0 && numcode[2] == 0) ||
				(numcode[0] == 1 && numcode[1] == 1 && numcode[2] == 1)) {
				colors = picoColcode(k);
				colors.length = colors.length < maxcolor * 3 ? colors.length : maxcolor * 3;
				depth = colors.length / 3;
				console.log("Load color: " + colors);

			// Load pixels to buffers.
			} else if (k < maxanime) {
				buffers[k] = numcode;
				anime = anime > k + 1 ? anime : k + 1;
				frameselecting = anime - 1;
				animeflag = 1;
				console.log("Load buffer" + k + ": " + buffers[k]);
			}
		}
	}

	// Main loop.
	for (;;) {

		// Load pixels to canvas.
		if (frame != frameselecting) {
			frame = frameselecting;
			if (frame >= 0 && buffers[frame]) {
				for (let j = 0; j < maxheight; j++) {
					pixels[j] = [];
				}
				for (let n = 0; n < buffers[frame].length; n += 3) {
					if (buffers[frame][n] == 0) {
						width = buffers[frame][n + 1] >= 0 && buffers[frame][n + 1] <= maxwidth ? buffers[frame][n + 1] : 7;
						height = buffers[frame][n + 2] >= 0 && buffers[frame][n + 2] <= maxheight ? buffers[frame][n + 2] : 7;
						xoffset = picoDiv(maxwidth - width, 2);
						yoffset = picoDiv(maxheight - height, 2);
					} else if (buffers[frame][n] > 0) {
						let i = buffers[frame][n + 1] + xoffset;
						let j = buffers[frame][n + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							pixels[j][i] = buffers[frame][n];
						}
					}
				}
			} else {
				for (let j = 0; j < maxheight; j++) {
					pixels[j] = [];
					for (let i = 0; i < maxwidth; i++) {
						pixels[j][i] = 0;
					}
				}
			}
			console.log("Load pixel: " + pixels);
		}
		updateIcons();

		// Load colors data.
		picoColor(colors);
		let colorselecting = colors.length / 3 - 1, colorselected = -1;

		const offset1 = -10, offset1a = 4;; // Offset of pixels from center.
		const offset2 = 14; // Offset of colors from bottom.
		const offset3 = 18, offset3b = 8; // Offset of buffer from top.
		let touching = 0; // Touching pixel(1) or color(2).

		// Playing loop.
		for (playing = 1; playing > 0; playing++) {
			picoClear();

			// Set touching state to avoid touching another area continuously.
			if (picoAction()) {
				touching = 0; // Touch nothing.
				updateIcons();
			}

			// Draw pixels.
			/*if (animeflag <= 1) */{
				let y0 = !animeflag ? offset1 : offset1a;
				let s0 = !animeflag ? 168 : 140;
				let size = width < height ? width : height;
				let grid = s0 / size;
				let margin = size <= 9 ? 2 : 1;
				let w0 = grid / 2 - 1; // Width for touching.
				let w1 = (grid - margin) / 2 - 1; // Width.
				for (let j = yoffset; j < yoffset + height; j++) {
					let y = (j - yoffset - (height - 1) / 2) * grid + y0;
					for (let i = xoffset; i < xoffset + width; i++) {
						let x = (i - xoffset - (width - 1) / 2) * grid;
						if (touching != 2 && picoMotion(x, y, grid/2)) {
							touching = 1; // Touch pixels.

							// Put pixel.
							if (pixels[j][i] != colorselecting) {
								pixels[j][i] = colorselecting;
							}

							// Cancel color editing.
							if (colorflag) {
								colorflag = 0;
								colorselected = -1;
								touching = 1; // Touch pixels.
								picoFlush();
							}
							picoPixel(pixels[j][i], x, y, w0, w0);
						} else {
							picoPixel(pixels[j][i], x, y, w1, w1);
						}
					}
				}

			// Draw preview.
			/*} else {
				let sprite = buffers[frame] ? buffers[frame] : [0, 7, 7];
				let y0 = !animeflag ? offset1 : offset1a;
				let s0 = 140;
				let size = picoSpriteSize(sprite);
				let s1 = s0 / size; // Preview scale.
				//let s2 = s1 * 0.95; // Touching scale.

				// Back to anime edit mode.
				if (picoAction(0, y0, 70, 70)) {

					// Paste pixels to buffers.
					updateIcons();

					animeflag = 1;
					picoFlush();

				} else if (picoMotion(0, y0, 70, 70)) {
					let size = picoSpriteSize(sprite);
					picoSprite(sprite, 0, 0, y0, 0, s2);
				} else {
					let size = picoSpriteSize(sprite);
					picoSprite(sprite, 0, 0, y0, 0, s1);
				}*/
			}

			// Draw anime editor.
			if (animeflag >= 1) {
				let imin = /*anime <= 1 ? 1 :*/ 0;
				for (let i = imin; i < anime; i++) {
					let x = anime <= 10 ? (i - (anime - 1) / 2) * 16 : (picoMod(i, 10) - (10 - 1) / 2) * 16;
					let y = -pico.Image.height/2 + (anime <= 10 ? offset3 : offset3 - offset3b + offset3b*2 * picoDiv(i, 10));
					/*if (frame == i) {
						picoSprite([0,9,9], 0, x, y, 0, 1);
					} else {*/
						let sprite = animeflag == 2 && i == frameselecting && buffers[frame] ? buffers[frame] :
							buffers[i] ? buffers[i] : [0, 7, 7];
						let size = picoSpriteSize(sprite);
						let s0 = 2.25 * 7 / size; // Frame scale for touching/selecting.
						let s1 = 2.0 * 7 / size; // Frame scale.
						let s2 = 2.75 * 7 / size; // Frame scale for holding.

						// Enter preview mode.
						if (picoAction(x, y, 8, 8)) {

							// Select same color.
							if (frameselected == i) {
								frame = frameselecting = i;

								// Paste pixels to buffers.
								updateIcons();

								// Toggle preview mode and edit mode.
								animeflag = animeflag == 1 ? 2 : 1;
								frameselected = -1;
								picoFlush();

							// Select different frame.
							} else {
								frameselected = frameselecting = i;
								picoBeep(0, 0.1);
							}

							// Touch holding frame.
							if (animeflag == 2) {
								picoSprite(sprite, 0, x, y, 0, s2);
							} else {
								picoSprite(sprite, 0, x, y, 0, s0);
							}

						} else if (picoMotion(x, y, 8, 8)) {

							// Select frame.
							frameselecting = i;

							// Reload to change buffer.
							if (animeflag <= 1) {
								playing = -1;
							}

							// Cancel color editing.
							if (colorflag) {
								colorflag = 0;
								colorselected = -1;
								touching = 0; // Touch buffers.
								picoFlush();
							}

							// Touch holding frame.
							if (animeflag == 2) {
								picoSprite(sprite, 0, x, y, 0, s2);
							} else {
								picoSprite(sprite, 0, x, y, 0, s0);
							}

						// Touch holding frame.
						} else if (animeflag == 2 && i == frameselecting) {
							picoSprite(sprite, 0, x, y, 0, s2);

						// Selecting frame.
						} else if (i == frameselecting) {
							picoSprite(sprite, 0, x, y, 0, s0);

						} else {
							picoSprite(sprite, 0, x, y, 0, s1);
						}
					//}
				}
			}

			// Draw colors.
			if (colorflag <= 0) {
				for (let i = 0; i < depth; i++) {
					let x = (i - (depth - 1) / 2) * 16;
					let y = pico.Image.height/2 - offset2;

					// Enter color mode.
					if (touching != 1 && picoAction(x, y, 8, 12)) {

						// Select same color.
						if (colorselected == i) {
							colorselecting = i;

							// Enter color edit mode.
							if (i > 0) {
								colorflag = 1;
								colorselected = -1;
								picoFlush();

							// Change background color.
							} else {
								colorselected = -1;
								for (let j = 0; j < 3; j++) {
									let c = colors[colorselecting * 3 + j];
									c = c <= 0 ? 255 : 0;
									colors[colorselecting * 3 + j] = c;
								}
							}

						// Select different color.
						} else {
							colorselected = colorselecting = i;
							picoBeep(0, 0.1);
						}
						picoChar("+", i, x, y, 0, 4);

					} else if (touching != 1 && picoMotion(x, y, 8, 12)) {
						touching = 2; // Touch colors.

						// Touch different color.
						if (colorselecting != i) {
							colorselected = colorselecting;
							colorselecting = i;
						}
						picoChar("+", i, x, y, 0, 3.5);
					} else if (i == colorselecting) {
						picoChar("+", i, x, y, 0, 4);
					} else {
						picoChar("-", i, x, y, 0, 4);
					}
				}

			// Draw color editor.
			} else {
				const compression = 2, maxcompresed = (1 << (8 - compression));

				// Draw buttons and color numbers.
				if (colorselecting > 0) {
					let s = 2;
					let x = - (10 - 1) / 2 * 16;
					let y = pico.Image.height/2 - offset2;

					// Back to pixel mode.
					if (picoAction(x, y, 8, 12)) {
						colorflag = 0;
						colorselected = -1;
						touching = 1; // Touch pixels.
						picoFlush();
					} else if (picoMotion(x, y, 8, 12)) {
						s = 3.5;
					}

					// Draw plus button.
					picoChar("+", colorselecting, x, y, 0, s);

					for (let i = 0; i < 3; i++) {
						let c = colors[colorselecting * 3 + i];

						// Decrease color number.
						let x = ((i * 3 + 1) - (10 - 1) / 2) * 16;
						s = 2;
						if (picoAction(x, y, 8, 12)) {
							c = (c + 1) >> compression; // Bit shift for compressed decrease.
							c = c - 1 > 0 ? c - 1 : 0; // Decrease.
							c = (c << compression) - 1; // Bit unshift.
							c = c > 0 ? c : 0;
						} else if (picoMotion(x, y, 8, 12)) {
							s = 3.5;
						}

						// Draw minus button.
						picoChar("<", colorselecting, x, y, 0, s);

						// Increase color number.
						x = ((i * 3 + 3) - (10 - 1) / 2) * 16;
						s = 2;
						if (picoAction(x, y, 8, 12)) {
							c = (c + 1) >> compression; // Bit shift for compressed increase.
							c = c + 1 < maxcompresed ? c + 1 : maxcompresed; // Increase.
							c = (c << compression) - 1; // Bit unshift.
						} else if (picoMotion(x, y, 8, 12)) {
							s = 3.5;
						}
						colors[colorselecting * 3 + i] = c;

						// Draw plus button.
						picoChar(">", colorselecting, x, y, 0, s);

						// Convert range 0-255 to 0-100.
						let c99 = picoDiv(colors[colorselecting * 3 + i] * 99, 255);
						let c00 = c99 >= 99 ? "100" : c99 >= 9 ? "" + (c99 + 1) : c99 >= 1 ? " " + (c99 + 1) : " 0";

						// Draw color numbers.
						x = ((i * 3 + 2) - (10 - 1) / 2) * 16;
						s = 2;
						picoChar(c00, colorselecting, x, y, 0, s);
					}
				}
			}

			await picoFlip();
			await picoRead();
		} // End of playing loop.
	} // End of main loop.
};
main();
</script><!--/Main-->
</body>
</html>
