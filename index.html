<html style="overflow:hidden; user-select:none;">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
<title>Pico</title>
<link rel="icon" type="image/svg" href="icon.svg" />
<link rel="apple-touch-icon" href="icon.png" sizes="192x192" />
<link rel="manifest" href="manifest.json" />
<link rel="stylesheet" href="stylesheet.css" />
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<a id="title" href="./index.html">Pico</a>
			<div id="subtitle">
				<a href="bros.html">.</a><a href="dice.html">.</a>
			</div>
		</div>
		<div class="menu center">
			<a class="item clear" id="prev" href="javascript:changePage(-1);"><</a>
			<a class="item light" id="share" href="javascript:share();">
				<div class="light" id="page">^</div>
				<img id="thumbnail" src="" />
			</a>
			<a class="item clear" id="next" href="javascript:changePage(+1);">></a>
		</div>
		<div class="menu">
			<a class="item clear" href="javascript:changeSize(-1);">-</a>
			<a class="item light" id="size" href="javascript:changeSize(0);">x7</a>
			<a class="item clear" href="javascript:changeSize(+1);">+</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
		<div class="offscreen"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>/
	<div id="version"></div>
</h6>
<!--script>console.log = () => {};</script!-->
<script src="daemon.js"></script>
<script src="image.js"></script>
<script src="param.js"></script>
<script src="sound.js"></script>
<script src="touch.js"></script>
<!--Data--><script>
var maxwidth = 20, maxheight = 20; // Canvas max size.
var width = 7, height = 7; // Canvas size.
var xoffset = picoDiv(maxwidth - width, 2); // Canvas offset.
var yoffset = picoDiv(maxheight - height, 2); // Canvas offset.
const maxpage = 20; // Buffer max page.
var page = 1; // Buffer page index.
var pagefix = false; // Page fix flag.
var buffers = []; // Pixels buffers.
var playing = 1; // Playing count.
var pixels = []; // Pixels.
var colors = [255,255,255,255,223,175,159,255,247,191,191,191,231,0,95,0,119,239,0,151,63,167,0,0,143,0,119,0,63,23]; // Colors.
const maxcolor = 10; // Color max size.
var url = null; // Referenced url.
</script><!--/Data-->
<!--Menu--><script>

// Enable or disable menu.
function updateMenu(id, enable, text=null, data=null) {
	let e = document.getElementById(id);
	if (e) {
		e.style.display = enable ? "flex" : "none";
		if (text) {
			e.innerText = text;
		}
		if (data) {
			e.src = data;
		}
	}
}

// Set darkmode.
async function darkmode() {
	let e = document.body;
	if (e) {
		e.style.backgroundColor ="#888";
		e.style.color ="#fff";
	}
	updateMenu("title", false);
	updateMenu("subtitle", false);
}

// Update thumbnail image.
async function updateThumbnail(force = true) {
	if (force || buffers[page - 1]) {
		//console.log("Update" + page + ": " + buffers[page - 1]);

		// Store pixels to buffers.
		if (!buffers[page - 1]) {
			buffers[page - 1] = [];
			for (let j = 0; j < maxheight; j++) {
				buffers[page - 1][j] = [];
				for (let i = 0; i < maxwidth; i++) {
					buffers[page - 1][j][i] = 0;
				}
			}
		}

		// Remove buffer if emtpy.
		let remove = true;
		for (let j = yoffset; j < yoffset + height; j++) {
			for (let i = xoffset; i < xoffset + width; i++) {
				if (pixels[j][i]) {
					remove = false;
				}
				buffers[page - 1][j][i] = pixels[j][i];
			}
		}
		if (remove) {
			buffers[page - 1] = null;
		}
	}

	if (buffers[page - 1]) {

		// Update thumbnail.
		const thick = 10;
		let offscreen = new pico.Image("offscreen", width * thick, height * thick);
		await offscreen.color(colors);
		await offscreen.pixel(0, 0, 0, width * thick, height * thick);
		for (let j = yoffset; j < yoffset + height; j++) {
			let y = (j - yoffset - (height - 1) / 2) * thick;
			for (let i = xoffset; i < xoffset + width; i++) {
				if (buffers[page - 1][j][i]) {
					let x = (i - xoffset - (width - 1) / 2) * thick;
					await offscreen.pixel(buffers[page - 1][j][i], x, y, (thick-1)/2, (thick-1)/2);
				}
			}
		}
		
		// Enable thumbnail.
		updateMenu("thumbnail", true, null, offscreen.data());
	} else {

		// Disable thumbnail.
		updateMenu("thumbnail", false);
	}

	// Update buttons.
	updateMenu("size", true, "x" + width);
	updateMenu("page", true, page >= 2 ? "" + page : "^");
	updateMenu("prev",  buffers[page - 1] && !pagefix || page >= 2);
	updateMenu("next",  buffers[page - 1] && !pagefix || page >= 2);
}

// Share.
async function share() {
	updateThumbnail();
	picoResetParams();

	// Create num code to share url.
	let k = 0;
	for (let p = 0; p < maxpage; p++) {
		if (k == 0 || buffers[p]) {
			let numcode = [0, width, height];
			if (buffers[p]) {
				for (let j = yoffset; j < yoffset + height; j++) {
					for (let i = xoffset; i < xoffset + width; i++) {
						if (buffers[p][j][i]) {
							let n = numcode.length;
							numcode[n] = buffers[p][j][i];
							numcode[n + 1] = i - xoffset;
							numcode[n + 2] = j - yoffset;
						}
					}
				}
			}
			picoSetNumcode(numcode, k);
			k++;
		}
	}
	if (((colors[0] == 255 && colors[1] == 255 && colors[2] == 255) ||
		(colors[0] == 0 && colors[1] == 0 && colors[2] == 0))) {
		picoSetColcode(colors, k);
	}

	// Start sharing.
	if (url) {
		await picoReload(url);
	} else {
		await picoShare();
	}
}

// Change canvas pave.
function changePage(x) {
	page = page + x < 1 ? 1 : page + x >= maxpage ? maxpage : page + x;
	//console.log("Page: " + page);
	playing = -1; // Restart.

	// Load pixels from buffers.
	if (buffers[page - 1]) {
		for (let j = 0; j < maxheight; j++) {
			pixels[j] = [];
			for (let i = 0; i < maxwidth; i++) {
				pixels[j][i] = buffers[page - 1][j][i];
			}
		}
	} else {
		for (let j = 0; j < maxheight; j++) {
			pixels[j] = [];
			for (let i = 0; i < maxwidth; i++) {
				pixels[j][i] = 0;
			}
		}
	}

	picoBeep(1.2, 0.1);
	updateThumbnail(false);
}

// Change canvas size.
function changeSize(x) {
	width = width + x < 3 ? 3 : width + x >= maxwidth ? maxwidth : width + x;
	height = height + x < 3 ? 3 : height + x >= maxheight ? maxheight : height + x;
	xoffset = picoDiv(maxwidth - width, 2);
	yoffset = picoDiv(maxheight - height, 2);
	//console.log("Size: " + width + "x" + height + " + " + xoffset + "," + yoffset);
	playing = -1; // Restart.

	picoBeep(1.2, 0.1);	
	updateThumbnail(false);
}
</script><!--/Menu-->
<!--Main--><script>
async function main() {

	// Initialize pixels on max size.
	for (let j = 0; j < maxheight; j++) {
		pixels[j] = [];
		for (let i = 0; i < maxwidth; i++) {
			pixels[j][i] = 0;
		}
	}

	// Load params.
	let keys = picoKeys();
	for (let k = 0; k < keys.length; k++) {
		console.log("Param" + k + ": " + keys[k] + " -> " + picoStrings(keys[k]));

		// Load referenced url.
		if (keys[k] == "u") {
			url = picoStrings(keys[k]);
			darkmode();

		// Load colors param.
		} else if (keys[k] == "z") {
			colors = picoNumbers(keys[k]);
			//colors = picoColcode(k);
			console.log("Color: " + colors);

		// Load pixels param.
		} else {
			let numcode = picoNumcode(k);

			// Load colors.
			if ((numcode[0] == 0 && numcode[1] == 0 && numcode[2] == 0) ||
				(numcode[0] == 1 && numcode[1] == 1 && numcode[2] == 1)) {
				colors = picoColcode(k);
				colors.length = colors.length < maxcolor * 3 ? colors.length : maxcolor * 3;
				console.log("Color: " + colors);

			// Load pixels to canvas.
			} else if (k == 0) {
				for (let n = 0; n < numcode.length; n += 3) {
					if (numcode[n] == 0) {
						width = numcode[n + 1] >= 0 && numcode[n + 1] < maxwidth ? numcode[n + 1] : 7;
						height = numcode[n + 2] >= 0 && numcode[n + 2] < maxheight ? numcode[n + 2] : 7;
						changeSize(0);
					} else if (numcode[n] > 0) {
						let i = numcode[n + 1] + xoffset;
						let j = numcode[n + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							pixels[j][i] = numcode[n];
						}

						pagefix = true; // Fix only one page.
					}
				}
				console.log("Pixel: " + pixels);

			// Load pixels to buffers.
			} else if (k < maxpage) {
				console.log("Load buffer" + k + ": " + maxpage);
				buffers[k] = [];
				for (let j = 0; j < maxheight; j++) {
					buffers[k][j] = [];
					for (let i = 0; i < maxwidth; i++) {
						buffers[k][j][i] = 0;
					}
				}
				for (let n = 0; n < numcode.length; n += 3) {
					if (numcode[n] > 0) {
						let i = numcode[n + 1] + xoffset;
						let j = numcode[n + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							buffers[k][j][i] = numcode[n];
						}
					}
				}
				pagefix = false; // Nofix two or more pages.
				console.log("Buffer" + k + ": " + buffers[k]);
			}
		}
	}
	updateThumbnail();

	// Load colors data.
	picoColor(colors);

	// Main loop.
	for (;;) {

		// Initial param.
		let select = colors.length / 3 - 1;
		let grid = 168 / width;
		let margin = width <= 9 ? 2 : 1;

		const offset1 = 6, offset2 = 10; // Offset of pixels and colors.
		let touching = 0; // Touching pixels(0) or colors(1).

		// Playing loop.
		for (playing = 1; playing > 0; playing++) {
			picoClear();

			// Set touching state to avoid touching another area continuously.
			if (picoAction()) {
				touching = 0;
				updateThumbnail();
			}

			// Draw pixels.
			for (let j = yoffset; j < yoffset + height; j++) {
				let y = (j - yoffset - (height - 1) / 2) * grid - offset1;
				for (let i = xoffset; i < xoffset + width; i++) {
					let x = (i - xoffset - (width - 1) / 2) * grid;
					if (touching != 2 && picoMotion(x, y, grid/2)) {
						touching = 1;
						if (pixels[j][i] != select) {
							pixels[j][i] = select;
						}
						picoPixel(pixels[j][i], x, y, grid/2-1, grid/2-1);
					} else {
						picoPixel(pixels[j][i], x, y, (grid-margin)/2-1, (grid-margin)/2-1);
					}
				}
			}

			// Draw colors.
			for (let i = 0; i < colors.length / 3; i++) {
				let x = (i - (colors.length / 3 - 1) / 2) * 16;
				let y = pico.Image.height/2 - offset2;
				if (touching != 1 && picoMotion(x, y, 8, 12)) {
					touching = 2;
					if (select != i) {
						select = i;
						picoBeep(0, 0.1);
					}
				}
				if (i == select) {
					picoChar("+", i, x, y, 0, 4);
				} else {
					picoChar("-", i, x, y, 0, 4);
				}
			}

			await picoFlip();
			await picoRead();
		} // End of playing loop.
	} // End of main loop.
};
main();
</script><!--/Main-->
</body>
</html>
