<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
<title>Pico</title>
<link rel="icon" type="image/svg" href="icon.svg" />
<link rel="apple-touch-icon" href="icon.png" sizes="192x192" />
<link rel="manifest" href="manifest.json" />
<link rel="stylesheet" href="stylesheet.css" />
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<a id="title" href="./index.html">Pico</a>
			<div id="subtitle">
				<a href="bros.html">.</a><a href="dice.html">.</a>
			</div>
		</div>
		<div class="menu center">
			<a class="item light secret" id="action" href="javascript:menuAction();">
				<span id="actionText"></span>
				<img class="icon" id="actionIcon" src="" />
			</a>
		</div>
		<div class="menu">
			<a class="item clear" id="minus" href="javascript:menuSelect(-1);">-</a>
			<a class="item light" id="select" href="javascript:menuSelect(0);">
				<span id="selectText"></span>
				<img class="icon" id="selectIcon" src="" />
			</a>
			<a class="item clear" id="plus" href="javascript:menuSelect(+1);">+</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>/
	<div id="version"></div>
</h6>
<!--script>console.log = () => {};</script!-->
<script src="daemon.js"></script>
<script src="image.js"></script>
<script src="param.js"></script>
<script src="sound.js"></script>
<script src="touch.js"></script>
<!--Data--><script>
var maxwidth = 20, maxheight = 20; // Canvas max size.
var width = 7, height = 7; // Canvas size.
var xoffset = picoDiv(maxwidth - width, 2); // Canvas offset.
var yoffset = picoDiv(maxheight - height, 2); // Canvas offset.
const maxanime = 20; // Buffer max size.
var anime = 1; // Buffer count.
var minanime = 1; // Buffer min index.
var frame = -1; // Anime frame count.
var frameselecting = 0; // Touching frame index.
var buffers = []; // Pixels buffers.
var animeflag = 0; // Anime editing flag.
var playing = 1; // Playing count.
var pixels = []; // Canvas pixels.
var colors = [255,255,255, 159,255,247, 255,223,175, 191,191,191, 0,119,239, 231,0,95, 0,151,63, 143,0,119, 167,0,0, 0,63,23]; // Colors.
var bgcolors = [255,255,255, 223,223,223, 191,191,191, 127,127,127, 63,63,63, 0,0,0]; // Background colors.
var depth = 10; // Color count.
const maxcolor = 10; // Color max size.
var colorflag = 0; // Color editing flag.
var appver = 0; // App version.
var appurl = null; // Referenced url.
</script><!--/Data-->
<!--Menu--><script>

// Enable or disable menu.
function updateMenu(id, enable, text=null, icon=null) {
	let e = document.getElementById(id);
	if (e) {
		e.style.display = enable ? "flex" : "none";
		let e1 = document.getElementById(id + "Text");
		let e2 = document.getElementById(id + "Icon");
		if (e1 && text) {
			e1.style.display = "flex";
			e1.innerText = text;
			if (e2 && !icon) {
				e2.style.display = "none";
			}
		}
		if (e2 && icon) {
			e2.style.display = "flex";
			e2.src = icon;
			if (e1 && !text) {
				e1.style.display = "none";
			}
		}
	}
}

// Set darkmode.
async function darkmode(enable) {
	let e = document.body;
	if (e) {
		if (enable) {
			e.classList.add("dark");
		} else {
			e.classList.remove("dark");
		}
	}
}

// Update buttons.
function updateButtons() {
	if (appurl) {
		updateMenu("title", false);
		updateMenu("subtitle", false);
	}
	/*if (colorflag) {
		updateMenu("select", true, "" + depth);
	} else*/ if (animeflag) {
		updateMenu("select", true, "" + anime);
	} else {
		updateMenu("select", true, "x" + width);
	}
}

// Update icon image.
async function updateIcons(force = true) {

	// Update buffer.
	if (force || buffers[frame]) {
		//console.log("Update" + frame + ": " + buffers[frame]);

		// Store canvas pixels to buffers.
		buffers[frame] = [0, width, height];
		for (let j = yoffset; j < yoffset + height; j++) {
			for (let i = xoffset; i < xoffset + width; i++) {
				if (pixels[j][i]) {
					let k = buffers[frame].length;
					buffers[frame][k] = pixels[j][i];
					buffers[frame][k+1] = i - xoffset;
					buffers[frame][k+2] = j - yoffset;
				}
			}
		}
		if (buffers[frame].length <= 3) {
			buffers[frame] = null;
		}
	}

	// Update icon image.
	if (buffers[frame]) {
		let data = await picoSpriteData(buffers[frame], colors);
		updateMenu("action", true, null, data);
	} else {
		updateMenu("action", true, "^");
	}
	updateButtons();
}

// Action button for back to app or start sharing.
async function menuAction() {

	// Back to app or start sharing.
	picoResetParams();

	// Create num code to share url.
	let k = 0;
	for (let p = 0; p < maxanime; p++) {
		if (buffers[p]) {
			picoSetNumcode(buffers[p], k);
			k++;
		}
	}
	if (k == 0) {
		picoSetNumcode([0,7,7], k);
		k++
	}
	if (
		((colors[0] == 255 && colors[1] == 255 && colors[2] == 255) ||
		(colors[0] == 0 && colors[1] == 0 && colors[2] == 0))) {
		picoSetColcode(colors, k);
	}

	// Back to app or start sharing.
	if (appurl) {
		await picoReload(appurl);
	} else {
		await picoShare();
	}
}

// Select button.
function menuSelect(x) {

	// Change menu mode.
	if (x == 0) {
		animeflag = animeflag ? 0 : 1;
	//	colorflag = 0;

	// Change color depth.
	//} else if (colorflag) {
	//	depth = depth + x < 1 ? 1 : depth + x >= maxcolor ? maxcolor : depth + x;

	// Change canvas frame.
	} else if (animeflag) {
		anime = anime + x < 1 ? 1 : anime + x >= maxanime ? maxanime : anime + x;
		if (frame >= anime) {
			frameselecting = anime - 1;
			playing = -1; // Restart.
		}

	// Change canvas size.
	} else {
		width = width + x < 3 ? 3 : width + x > maxwidth ? maxwidth : width + x;
		height = height + x < 3 ? 3 : height + x > maxheight ? maxheight : height + x;
		xoffset = picoDiv(maxwidth - width, 2);
		yoffset = picoDiv(maxheight - height, 2);
		//console.log("Size: " + width + "x" + height + " + " + xoffset + "," + yoffset);
		//playing = -1; // Restart.
	}

	picoBeep(1.2, 0.1);	
	updateIcons(false);
	picoFlush();
}
</script><!--/Menu-->
<!--Main--><script>
async function main() {

	// Initialize pixels on max size.
	for (let j = 0; j < maxheight; j++) {
		pixels[j] = [];
		for (let i = 0; i < maxwidth; i++) {
			pixels[j][i] = 0;
		}
	}

	// Load params.
	let keys = picoKeys();

	// Load data and frames.
	let frametouching = 0; // -1:invalid, 0:untouched, 1:touching.
	let frameselected = -1; // Previous touched frame index.
	frameselecting = 0;
	for (let k = 0; k < keys.length; k++) {
		console.log("Param" + k + ": " + keys[k] + " -> " + picoStrings(keys[k]));

		// Load version.
		if (keys[k] == "v") {
			appver = picoStrings(keys[k]);

		// Load referenced url.
		} else if (keys[k] == "u") {
			appurl = picoStrings(keys[k]);
			//darkmode(true);
			updateButtons();

		// Load pixels param.
		} else {
			let numcode = picoNumcode(k);

			// Load colors.
			if ((numcode[0] == 0 && numcode[1] == 0 && numcode[2] == 0) ||
				(numcode[0] == 1 && numcode[1] == 1 && numcode[2] == 1)) {
				colors = picoColcode(k);
				colors.length = colors.length < maxcolor * 3 ? colors.length : maxcolor * 3;
				depth = colors.length / 3;
				console.log("Load color: " + colors);

			// Load pixels to buffers.
			} else if (k < maxanime) {
				buffers[k] = numcode;
				anime = anime > k + 1 ? anime : k + 1;
				frameselecting = anime - 1;
				if (anime >= 2) {
					animeflag = 1;
				}
				console.log("Load buffer" + k + ": " + buffers[k]);
			}
		}
	}

	// Main loop.
	for (;;) {

		// Load pixels to canvas.
		if (frame != frameselecting) {
			frame = frameselecting;
			if (frame >= 0 && buffers[frame]) {
				for (let j = 0; j < maxheight; j++) {
					pixels[j] = [];
				}
				if (buffers[frame][0] == 0) {
					width = buffers[frame][0 + 1] >= 0 && buffers[frame][0 + 1] <= maxwidth ? buffers[frame][0 + 1] : 7;
					height = buffers[frame][0 + 2] >= 0 && buffers[frame][0 + 2] <= maxheight ? buffers[frame][0 + 2] : 7;
					xoffset = picoDiv(maxwidth - width, 2);
					yoffset = picoDiv(maxheight - height, 2);
				}
				for (let n = 3; n < buffers[frame].length; n += 3) {
					if (buffers[frame][n + 3] == 0) {
						let imax = buffers[frame][n + 1] + buffers[frame][n + 4] + xoffset;
						let jmax = buffers[frame][n + 2] + buffers[frame][n + 5] + yoffset;
						//console.log("Put pixel: " + "->" + imax + "," + jmax);
						for (let i = buffers[frame][n + 1] + xoffset; i <= imax; i++) {
							for (let j = buffers[frame][n + 2] + yoffset; j <= jmax; j++) {
								//console.log("Put pixel: " + i + "," + j);
								if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
									pixels[j][i] = buffers[frame][n];
								}
							}
						}
						n += 3;
					} else {
						let i = buffers[frame][n + 1] + xoffset;
						let j = buffers[frame][n + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							pixels[j][i] = buffers[frame][n];
						}
					}
				}
			} else {
				for (let j = 0; j < maxheight; j++) {
					pixels[j] = [];
					for (let i = 0; i < maxwidth; i++) {
						pixels[j][i] = 0;
					}
				}
			}
			console.log("Load pixel: " + pixels);
		}
		updateIcons();

		// Color touching flags and states.
		let bgindex = 1; // Background color index.
		let colortouching = 0; // -1:invalid, 0:untouched, 1:touching.
		let colorselecting = depth - 1; // Touching color index.
		let colorselected = -1; // Previous touched color index.
		let touching = 0; // Touching pixel(1) or color(2) or frame(3).

		// Playing loop.
		for (playing = 1; playing > 0; playing++) {
			picoClear();

			// Set touching state to avoid touching another area continuously.
			if (picoAction()) {
				console.log("Set touching state.");
				touching = 0; // Touch nothing.
				colortouching = 0;
				frametouching = 0;
				updateIcons();
			}

			// Draw background color.
			picoColor(bgcolors);
			picoPixel(bgindex, 0, 0, 100, 100);

			// Set colors data.
			picoColor(colors);

			// Draw pixels.
			{
				let y0 = !animeflag ? -10 : 4; // Offset of pixels from center.
				let s0 = !animeflag ? 168 : 140; // 168,140 for size7(grid24,20) / 162,144 for size9(grid18,16)
				let size = width < height ? width : height;
				let grid = s0 / size;
				let margin = size <= 9 ? 2 : 1;
				let w0 = grid / 2 - 1; // Width for touching.
				let w1 = (grid - margin) / 2 - 1; // Width.
				for (let j = yoffset; j < yoffset + height; j++) {
					let y = (j - yoffset - (height - 1) / 2) * grid + y0;
					for (let i = xoffset; i < xoffset + width; i++) {
						let x = (i - xoffset - (width - 1) / 2) * grid;
						if (touching != 2 && touching != 3 && picoMotion(x, y, grid/2)) {
							console.log("Touch pixels.");
							touching = 1; // Touch pixels.
							colortouching = -1;

							// Put pixel.
							if (pixels[j][i] != colorselecting) {
								pixels[j][i] = colorselecting;
							}

							// Cancel color editing.
							if (colorflag) {
								console.log("Cancel color editing.");
								touching = 1; // Touch pixels.
								colorflag = 0;
								colortouching = 0;
								colorselected = -1;
								picoFlush();
							}
							picoPixel(pixels[j][i], x, y, w0, w0);
						} else {
							picoPixel(pixels[j][i], x, y, w1, w1);
						}
					}
				}
			}

			// Draw anime editor.
			if (animeflag >= 1) {
				let imin = /*anime <= 1 ? 1 :*/ 0;
				for (let i = imin; i < anime; i++) {
					let x = anime <= 10 ? (i - (anime - 1) / 2) * 16 : (picoMod(i, 10) - (10 - 1) / 2) * 16;
					let y = -pico.Image.height/2 + (anime <= 10 ? 18 : 10 + 16 * picoDiv(i, 10)); // Offset of buffer from top.
					let sprite = animeflag == 2 && i == frameselecting && buffers[frame] ? buffers[frame] :
						buffers[i] ? buffers[i] : [0, 7, 7];
					let s = 7 / picoSpriteSize(sprite);

					// Release touching frame.
					if (frametouching >= 0 && picoAction(x, y, 8, 8)) {
						console.log("Release touching frame.");
						frametouching = 0;

						// Double touched frame.
						if (frameselected == i) {
							console.log("Double touched frame.");
							frameselected = -1;
							frame = frameselecting = i;

							// Copy and holding.
							if (animeflag == 1) {
								console.log("Copy and holding.");
								animeflag = 2;
								picoFlush(); // Update after action event.
								picoBeep(1.2, 0.1);
							}

						// Single touched frame.
						} else if (frameselected == -1) {
							console.log("Single touched frame.");

							// Paste and release.
							if (animeflag == 2) {
								console.log("Paste and release.");
								frame = frameselecting = i;
								updateIcons(); // Paste pixels to buffers.
								animeflag = 1;
								picoBeep(1.2, 0.1);
							} else {
								frameselected = frameselecting;
								picoBeep(0, 0.1);
							}

						// Touched frame after hovering.
						} else {
							console.log("Touched frame after hovering:" + frameselected);
							frameselected = -1;

							// Paste and release.
							if (animeflag == 2) {
								console.log("Paste and release.");
								frame = frameselecting = i;
								updateIcons(); // Paste pixels to buffers.
								animeflag = 1;
								picoBeep(1.2, 0.1);
							} else {
								picoBeep(0, 0.1);
							}
						}

						// Touch holding frame.
						if (animeflag == 2) {
							picoSprite(sprite, 0, x, y, 0, 2.75 * s); // Frame scale for holding.
						} else {
							picoSprite(sprite, 0, x, y, 0, 2.25 * s);; // Frame scale for touching/selecting.
						}

					// Touching frame.
					} else if (frametouching >= 0 && picoMotion(x, y, 8, 8)) {

						// Start to touching frame.
						if (frametouching == 0 && frameselected == frameselecting) {
							console.log("Retouching frame.");
							touching = 3; // Touch frames.
							frametouching = 1;
							frameselecting = i;

						// Start to touching another frame.
						} else if (frametouching == 0) {
							console.log("Touching frame.");
							touching = 3; // Touch frames.
							frametouching = 1;
							frameselecting = i;

						// Hovering to another frame.
						} else if (frameselecting != i) {
							console.log("Touching another frame.");
							frameselecting = i;
							frameselected = -2;

						// Continue touching frame.
						} else {
							console.log("Continue touching frame:" + frameselected);
						}

						// Reload to change buffer.
						if (animeflag <= 1) {
							playing = -1;
						}

						// Cancel color editing.
						if (colorflag) {
							console.log("Cancel color editing.");
							touching = 0; // Touch buffers.
							colorflag = 0;
							colortouching = 0;
							colorselected = -1;
						}

						// Touch holding frame.
						if (animeflag == 2) {
							picoSprite(sprite, 0, x, y, 0, 2.75 * s); // Frame scale for holding.
						} else {
							picoSprite(sprite, 0, x, y, 0, 2.25 * s); // Frame scale for touching/selecting.
						}

					// Not touching but selecting color.
					} else if (i == frameselecting) {

						// Touch holding frame.
						if (animeflag == 2) {
							picoSprite(sprite, 0, x, y, 0, 2.75 * s); // Frame scale for holding.
						} else {
							picoSprite(sprite, 0, x, y, 0, 2.25 * s);; // Frame scale for touching/selecting.
						}

					// Other frames.
					} else {
						picoSprite(sprite, 0, x, y, 0, 2.0 * s); // Frame scale.
					}
				}
			}

			// Touching background.
			let backgroundtouching = false;
			{
				let y = pico.Image.height/2 - 14; // Offset of colors/coloreditor from bottom.

				// Release touching background.
				if (colortouching >= 0 && picoAction(0, 0, 100, 100) && !picoAction(0, y, 84, 94)) {
					console.log("Release touching background.");
					touching = 0; // Touch nothing.
					colortouching = 0;

					// Double touched background.
					if (colorselected == 0) {
						console.log("Double touched background.");
						colorselected = -1;

						// Change background color.
						let c = colors[0];
						colors[0] = colors[1] = colors[2] = c > 0 ? 0 : 255;
						bgindex = colors[0] > 0 ? 1 : 4;
						picoBeep(1.2, 0.1);

					// Single touched background.
					} else if (colorselected == -1) {
						console.log("Single touched background.");

						if (colorflag <= 0) {
							colorselected = colorselecting;
							picoBeep(0, 0.1);

						// Back to pixel mode.
						} else {
							console.log("Back to pixel mode.");
							touching = 2; // Continue touching colors.
							colorflag = 0;
							colortouching = 0;
							colorselected = -1;
							picoFlush(); // Update after action event.
							picoBeep(1.2, 0.1);
						}

					// Touched background after hovering.
					} else {
						console.log("Touched color after hovering:" + colorselected);
						colorselected = -1;
						picoBeep(0, 0.1);
					}

				// Touching background.
				} else if (colortouching >= 0 && picoMotion(0, 0, 100, 100) && !picoMotion(0, y, 84, 94)) {

					if (colorflag <= 0) {
						// Start to touching background.
						if (colortouching == 0) {
							console.log("Touching background.");
							colorselecting = 0;

						// Hovering from another color.
						} else if (colorselecting != 0) {
							console.log("Touching another background.");
							colorselecting = 0;
							colorselected = -2;

						// Continue touching background.
						} else {
							console.log("Continue touching background:" + colorselected);
						}
					}

					touching = 2; // Touch colors.
					colortouching = 1;
					backgroundtouching = true;
				}
			}

			// Draw colors.
			if (colorflag <= 0) {
				let y = pico.Image.height/2 - 14; // Offset of colors from bottom.
				let grid = 20;

				for (let i = 1; i < depth; i++) {
					let x = (i-1 - (depth-1 - 1) / 2) * grid; // Margins for each color.

					// Release touching color.
					if (colortouching >= 0 && picoAction(x, y, 8, 12)) {
						console.log("Release touching color.");
						touching = 0; // Touch nothing.
						colortouching = 0;

						// Double touched color.
						if (colorselected == i) {
							console.log("Double touched color.");
							colorselected = -1;

							// Enter color edit mode.
							colorflag = 1;
							picoFlush(); // Update after action event.
							picoBeep(1.2, 0.1);

						// Single touched color.
						} else if (colorselected == -1) {
							console.log("Single touched color.");
							colorselected = colorselecting;
							picoBeep(0, 0.1);

						// Touched color after hovering.
						} else {
							console.log("Touched color after hovering:" + colorselected);
							colorselected = -1;
							picoBeep(0, 0.1);
						}
						picoChar("+", i, x, y, 0, 4);

					// Touching color.
					} else if (colortouching >= 0 && picoMotion(x, y, 8, 12)) {

						// Start to touching color.
						if (colortouching == 0 && colorselected == colorselecting) {
							console.log("Retouching color.");
							touching = 2; // Touch colors.
							colortouching = 1;
							colorselecting = i;

						// Start to touching another color.
						} else if (colortouching == 0) {
							console.log("Touching color.");
							touching = 2; // Touch colors.
							colortouching = 1;
							colorselecting = i;

						// Hovering to another color.
						} else if (colorselecting != i) {
							console.log("Touching another color.");
							colorselecting = i;
							colorselected = -2;

						// Continue touching color.
						} else {
							console.log("Continue touching color:" + colorselected);
						}
						picoChar("+", i, x, y, 0, 3.5);

					} else {
						let s = backgroundtouching ? 3.5 : 4;

						// Not touching but selecting color.
						if (colorselecting == i) {
							picoChar("+", i, x, y, 0, s);

						// Other colors.
						} else {
							picoChar("-", i, x, y, 0, s);
						}
					}
				}

			// Draw color editor.
			} else {
				const compression = 2, maxcompresed = (1 << (8 - compression));
				let y = pico.Image.height/2 - 14; // Offset of coloreditor from bottom.
				let grid = 20;

				// Draw buttons and color numbers.
				if (colorselecting > 0) {
					for (let i = 0; i < 3; i++) {
						let c = colors[colorselecting * 3 + i];

						// Decrease color number.
						if (c > 0) {
							let x = (i*3 - (9 - 1) / 2) * grid; // Margins for each color number.
							let s = backgroundtouching ? 3.5 : 4;
							if (picoAction(x, y+6, 8, 6)) {
								c = (c + 1) >> compression; // Bit shift for compressed decrease.
								c = c - 1 > 0 ? c - 1 : 0; // Decrease.
								c = (c << compression) - 1; // Bit unshift.
								c = c > 0 ? c : 0;
							} else if (picoMotion(x, y+6, 8, 6)) {
								s = 3.5;
							}

							// Draw decrease button.
							picoChar("_", colorselecting, x, y, 0, s);
						}

						// Increase color number.
						if (c < 255) {
							let x = (i*3 - (9 - 1) / 2) * grid; // Margins for each color number.
							let s = backgroundtouching ? 3.5 : 4;
							if (picoAction(x, y-6, 8, 6)) {
								c = (c + 1) >> compression; // Bit shift for compressed increase.
								c = c + 1 < maxcompresed ? c + 1 : maxcompresed; // Increase.
								c = (c << compression) - 1; // Bit unshift.
							} else if (picoMotion(x, y-6, 8, 6)) {
								s = 3.5;
							}
							colors[colorselecting * 3 + i] = c;

							// Draw increase button.
							picoChar("^", colorselecting, x, y, 0, s);
						}

						// Convert range 0-255 to 0-100.
						let c99 = picoDiv(colors[colorselecting * 3 + i] * 99, 255);
						let c00 = c99 >= 99 ? "100" : c99 >= 9 ? " " + (c99 + 1) : c99 >= 1 ? " 0" + (c99 + 1) : " 00";

						// Draw color numbers.
						let x = (i*3+1 - (9 - 1) / 2) * grid; // Margins for each color number.
						let s = backgroundtouching ? 3.5 : 4;
						picoChar(c00, colorselecting, x, y, 0, s);
					}
				}
			}

			await picoFlip();
			await picoRead();
		} // End of playing loop.
	} // End of main loop.
};
main();
</script><!--/Main-->
</body>
</html>
