<html style="overflow:hidden; user-select:none;">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title>Pico</title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<link rel="manifest" href="manifest.json">
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
	color: #888;
}
a {
	color: #ccc;
	text-decoration: none;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#header {
	margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
}
#contents {
	position: relative;
	width: 100%; height: 100%; margin: 8px;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #ccc;
}
#screen {
	aspect-ratio: 1;
}
.offscreen {
	display: none;
}
#footer {
	width: 100%; height: 12px; margin-top: -8px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
	font-size: 12px;
	color: #eee;
}
.logo {
	height: 60px; margin: 0px 16px;
	display: none;
}
.logo #icon {
	width: 40px; height: 40px; padding: 10px; margin-left: -28px;
}
.logo #title {
	font-size: 24px;
}
.logo #subtitle {
	font-size: 24px;
}
.menu {
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: flex-end; -webkit-align-items: flex-end;
}
.item {
	width: 40px; height: 40px; margin: 0px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	font-size: 16px;
}
.item #icon {
	width: 32px; height: 32px;
	position: absolute;
	left: 50%; transform: translate(-50%, 0);
	display: none;
}
.item.count {
	display: none;
}
.item.dark {
	background-color: #888;
	color: #fff;
}
.light {;
	background-color: #ccc;
	color: #888;
}
.menu a {
	transform: scale(1);
	opacity: 1;
}
.menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
.menu a:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (max-height: 400px) {
	#container {
		flex-direction: row; -webkit-flex-direction: row;
	}
	#header {
		order: 1; height: 100%;
		display: flex; display: -webkit-flex;
		flex-direction: column; -webkit-flex-direction: column;
		justify-content: center; -webkit-justify-content: center;
		align-items: center; -webkit-align-items: center;
	}
	.menu {
		display: flex; display: -webkit-flex;
		flex-direction: column; -webkit-flex-direction: column;
		justify-content: space-between; -webkit-justify-content: space-between;
		align-items: flex-end; -webkit-align-items: flex-end;
	}
	.center {
		position: absolute;
		top: 8px;
	}
}
@media (min-height: 401px) {
	#header {
		width: 100%;
	}
	@media (max-width: 350px) {
		.center {
			position: absolute;
			left: 8px;
		}
	}
	@media (min-width: 351px) {
		#header {
			display: flex; display: -webkit-flex;
			flex-direction: row; -webkit-flex-direction: row;
			justify-content: space-between; -webkit-justify-content: space-between;
			align-items: center; -webkit-align-items: center;
		}
		.center {
			position: absolute;
			left: 50%; transform: translate(-50%, 0);
		}
		.logo {
			display: flex; display: -webkit-flex;
			flex-direction: row; -webkit-flex-direction: row;
			justify-content: flex-start; -webkit-justify-content: flex-start;
			align-items: center; -webkit-align-items: center;
		}
	}
}
@media (orientation: landscape) {
	#screen {
		height: 100%;
	}
}
@media (orientation: portrait) {
	#contents {
		display: flex; display: -webkit-flex;
		flex-direction: column; -webkit-flex-direction: column;
		justify-content: center; -webkit-justify-content: center;
		align-items: center; -webkit-align-items: center;
	}
	#screen {
		width: 100%;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<a id="title" href="javascript:top.location.reload();">Pico</a>
			<a id="subtitle" href="javascript:top.location.reload();"></a>
		</div>
		<div class="menu center">
			<a class="item clear count" href="javascript:changeCount(-1);"><</a>
			<a class="item light" id="share" href="javascript:share();">
				<div class="light" id="count">^</div>
				<img id="icon" src="" />
			</a>
			<a class="item clear count" href="javascript:changeCount(+1);">></a>
		</div>
		<div class="menu">
			<a class="item clear" href="javascript:changeSize(-1);">-</a>
			<a class="item light" id="size" href="javascript:top.location.reload();">x7</a>
			<a class="item clear" href="javascript:changeSize(+1);">+</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
		<div class="offscreen"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>/
	<div id="version"></div>
</h6>
<!--script>console.log = () => {};</script!-->
<script src="daemon.js"></script>
<script src="image.js"></script>
<script src="param.js"></script>
<script src="sound.js"></script>
<script src="touch.js"></script>
<!--Data--><script>
var maxwidth = 20, maxheight = 20; // Canvas max size.
var width = 7, height = 7; // Canvas size.
var xoffset = picoDiv(maxwidth - width, 2); // Canvas offset.
var yoffset = picoDiv(maxheight - height, 2); // Canvas offset.
var maxcount = 1; // Buffer max count.
var count = 1; // Buffer count.
var buffers = []; // Pixels buffers.
var playing = 1; // Playing count.
var pixels = []; // Pixels.
//const colors8 = [255,255,255,255,219,171,159,255,243,188,188,188,231,0,91,0,115,239,0,147,59,167,0,0,143,0,119,0,63,23]; // Color uses original 8 bits.
//const colors6 = [255,255,255,255,223,175,159,255,247,191,191,191,231,0,95,0,119,239,0,151,63,167,0,0,143,0,119,0,63,23]; // Color uses 6 bits.
//const colors5 = [255,255,255,255,223,175,159,255,247,191,191,191,231,0,95,0,119,239,0,151,63,167,0,0,143,0,119,0,63,23]; // Color uses 5 bits.
var colors = [255,255,255,255,223,175,159,255,247,191,191,191,231,0,95,0,119,239,0,151,63,167,0,0,143,0,119,0,63,23];
var url = null; // Referenced url.
</script><!--/Data-->
<!--Menu--><script>

	// Set darkmode.
	async function changeMode(darkmode=true) {
		let e = document.body;
		if (e) {
			e.style.backgroundColor = darkmode ? "#888" : "#fff";
			e.style.color = darkmode ? "#fff" : "#888";
		}
	}
	
	// Update thumbnail image.
	async function updateThumbnail(force = true) {
		if (force || buffers[count - 1]) {
			//console.log("Update" + count + ": " + buffers[count - 1]);

			// Store pixels to buffers.
			if (!buffers[count - 1]) {
				buffers[count - 1] = [];
				for (let j = 0; j < maxheight; j++) {
					buffers[count - 1][j] = [];
					for (let i = 0; i < maxwidth; i++) {
						buffers[count - 1][j][i] = 0;
					}
				}
			}
			let remove = true;
			for (let j = yoffset; j < yoffset + height; j++) {
				for (let i = xoffset; i < xoffset + width; i++) {
					if (pixels[j][i]) {
						remove = false;
					}
					buffers[count - 1][j][i] = pixels[j][i];
				}
			}
			if (remove) {
				buffers[count - 1] = null;
			}
		}

		if (buffers[count - 1]) {

			// Update thumbnail.
			const thick = 10;
			let offscreen = new pico.Image("offscreen", width * thick, height * thick);
			await offscreen.color(colors);
			await offscreen.pixel(0, 0, 0, width * thick, height * thick);
			for (let j = yoffset; j < yoffset + height; j++) {
				let y = (j - yoffset - (height - 1) / 2) * thick;
				for (let i = xoffset; i < xoffset + width; i++) {
					if (buffers[count - 1][j][i]) {
						let x = (i - xoffset - (width - 1) / 2) * thick;
						await offscreen.pixel(buffers[count - 1][j][i], x, y, (thick-1)/2, (thick-1)/2);
					}
				}
			}
			
			// Enable thumbnail.
			let e = document.getElementById("icon");
			if (e) {
				e.style.display = "flex";
				e.src = offscreen.data();
			}
		} else {

			// Disable thumbnail.
			let e = document.getElementById("icon");
			if (e) {
				e.style.display = "none";
			}
		}

		// Update count button.
		let e = document.getElementById("size");
		if (e) {
			e.innerText = "x" + width;
		}
		if (maxcount >= 2) {
			e = document.getElementById("count");
			if (e) {
				e.innerText = "" + count;
			}
			e = document.getElementsByClassName("count");
			for (let i = 0; i < e.length; i++) {
				e[i].style.display = "flex";
			}
		} else {
			e = document.getElementById("count");
			if (e) {
				e.innerText = "^";
			}
			e = document.getElementsByClassName("count");
			for (let i = 0; i < e.length; i++) {
				e[i].style.display = "none";
			}
		}
	}

	// Share.
	async function share() {
		updateThumbnail();
		picoResetParams();

		// Create num code to share url.
		let hmax = 0;
		for (let h = 0; h < maxcount; h++) {
			if (buffers[h]) {
				let numcode = [0, width, height];
				for (let j = yoffset; j < yoffset + height; j++) {
					for (let i = xoffset; i < xoffset + width; i++) {
						if (buffers[h][j][i]) {
							let k = numcode.length;
							numcode[k + 0] = buffers[h][j][i];
							numcode[k + 1] = i - xoffset;
							numcode[k + 2] = j - yoffset;
						}
					}
				}
				picoSetNumcode(numcode, h);
				hmax = h + 1;
			}
		}
		if (hmax > 0 &&
			((colors[0] == 255 && colors[1] == 255 && colors[2] == 255) ||
			(colors[0] == 0 && colors[1] == 0 && colors[2] == 0))) {
			picoSetColcode(colors, hmax);
		}

		// Start sharing.
		if (url) {
			await picoReload(url);
		} else {
			await picoShare();
		}
	}

	// Change canvas count.
	function changeCount(x) {
			
		// Update vars.
		count = count + x < 1 ? 1 : count + x >= maxcount ? maxcount : count + x;
		//console.log("Count: " + count);
		playing = -1; // Restart.

		// Load pixels from buffers.
		if (buffers[count - 1]) {
			for (let j = 0; j < maxheight; j++) {
				pixels[j] = [];
				for (let i = 0; i < maxwidth; i++) {
					pixels[j][i] = buffers[count - 1][j][i];
				}
			}
		} else {
			for (let j = 0; j < maxheight; j++) {
				pixels[j] = [];
				for (let i = 0; i < maxwidth; i++) {
					pixels[j][i] = 0;
				}
			}
		}

		picoBeep(1.2, 0.1);
		updateThumbnail(false);
	}
	
	// Change canvas size.
	function changeSize(x) {
			
		// Update vars.
		width = width + x < 3 ? 3 : width + x >= maxwidth ? maxwidth : width + x;
		height = height + x < 3 ? 3 : height + x >= maxheight ? maxheight : height + x;
		xoffset = picoDiv(maxwidth - width, 2);
		yoffset = picoDiv(maxheight - height, 2);
		//console.log("Size: " + width + "x" + height + " + " + xoffset + "," + yoffset);
		playing = -1; // Restart.

		picoBeep(1.2, 0.1);	
		updateThumbnail(false);
	}
</script><!--/Menu-->
<!--Main--><script>
async function main() {

	// Load query params.
	for (let j = 0; j < maxheight; j++) {
		pixels[j] = [];
		for (let i = 0; i < maxwidth; i++) {
			pixels[j][i] = 0;
		}
	}

	// Load params.
	let keys = picoKeys();
	for (let h = 0; h < keys.length; h++) {
		console.log("Param" + h + ": " + keys[h] + " -> " + picoStrings(keys[h]));

		// Load referenced url.
		if (keys[h] == "u") {
			url = picoStrings(keys[h]);
			changeMode();

		// Load count param.
		} else if (keys[h] == "w") {
			let w = picoNumbers(keys[h])[0];
			maxcount = w <= 0 ? 0 : w < 20 ? w : 20;
			changeCount(0);

		// Load size param.
		} else if (keys[h] == "x") {
			let x = picoNumbers(keys[h])[0];
			maxwidth = maxheight = x <= 0 ? 0 : x < 20 ? x : 20;
			changeSize(0);

		// Load colors param.
		} else if (keys[h] == "z") {
			colors = picoNumbers(keys[h]);
			//colors = picoColcode(h);
			console.log("Color: " + colors);

		// Load pixels param.
		} else {
			let numcode = picoNumcode(h);

			// Load colors.
			if ((numcode[0] == 0 && numcode[1] == 0 && numcode[2] == 0) ||
				(numcode[0] == 1 && numcode[1] == 1 && numcode[2] == 1)) {
				colors = picoColcode(h);
				console.log("Color: " + colors);

			// Load pixels to canvas.
			} else if (h == 0) {
				for (let k = 0; k < numcode.length; k += 3) {
					if (numcode[k] == 0) {
						width = numcode[k + 1] >= 0 && numcode[k + 1] < maxwidth ? numcode[k + 1] : 7;
						height = numcode[k + 2] >= 0 && numcode[k + 2] < maxheight ? numcode[k + 2] : 7;
						changeSize(0);
					} else if (numcode[k] > 0) {
						let i = numcode[k + 1] + xoffset;
						let j = numcode[k + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							pixels[j][i] = numcode[k];
						}
					}
				}
				console.log("Pixel: " + pixels);
				updateThumbnail();

			// Load pixels to buffers.
			} else if (h < 20) {
				//console.log("Load buffer" + h + ": " + maxcount);
				buffers[h] = [];
				for (let j = 0; j < maxheight; j++) {
					buffers[h][j] = [];
					for (let i = 0; i < maxwidth; i++) {
						buffers[h][j][i] = 0;
					}
				}
				for (let k = 0; k < numcode.length; k += 3) {
					if (numcode[k] > 0) {
						let i = numcode[k + 1] + xoffset;
						let j = numcode[k + 2] + yoffset;
						if (i >= xoffset && i < xoffset + width && j >= yoffset && j < yoffset + height) {
							buffers[h][j][i] = numcode[k];
						}
					}
				}
				console.log("Buffer" + h + ": " + buffers[h]);
				if (h >= maxcount) {
					maxcount = h + 1;
					changeCount(0);
				}
			}
		}
	}

	// Load colors data.
	picoColor(colors);

	// Main loop.
	for (;;) {

		// Initial param.
		let select = colors.length / 3 - 1;
		let grid = 168 / width;
		let margin = width <= 9 ? 2 : 1;

		const offset1 = 6, offset2 = 10; // Offset of pixels and colors.
		let touching = 0; // Touching pixels(0) or colors(1).

		// Playing loop.
		for (playing = 1; playing > 0; playing++) {
			picoClear();

			// Set touching state to avoid touching another area continuously.
			if (picoAction()) {
				touching = 0;
				updateThumbnail();
			}

			// Draw pixels.
			for (let j = yoffset; j < yoffset + height; j++) {
				let y = (j - yoffset - (height - 1) / 2) * grid - offset1;
				for (let i = xoffset; i < xoffset + width; i++) {
					let x = (i - xoffset - (width - 1) / 2) * grid;
					if (touching != 2 && picoMotion(x, y, grid/2)) {
						touching = 1;
						if (pixels[j][i] != select) {
							pixels[j][i] = select;
						}
						picoPixel(pixels[j][i], x, y, grid/2-1, grid/2-1);
					} else {
						picoPixel(pixels[j][i], x, y, (grid-margin)/2-1, (grid-margin)/2-1);
					}
				}
			}

			// Draw colors.
			for (let i = 0; i < colors.length / 3; i++) {
				let x = (i - (colors.length / 3 - 1) / 2) * 16;
				let y = pico.Image.height/2 - offset2;
				if (touching != 1 && picoMotion(x, y, 8, 12)) {
					touching = 2;
					if (select != i) {
						select = i;
						picoBeep(0, 0.1);
					}
				}
				if (i == select) {
					picoChar("+", i, x, y, 0, 4);
				} else {
					picoChar("-", i, x, y, 0, 4);
				}
			}

			await picoFlip();
			await picoRead();
		} // End of playing loop.
	} // End of main loop.
};
main();
</script><!--/Main-->
</body>
</html>
